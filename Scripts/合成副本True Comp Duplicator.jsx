{///////////////////////////////////////////////////////////////////////////                                                                          // True Comp Duplicator v2.1//// ©2010 Brennan Chapman// Author: Brennan Chapman// 2.0 enhancements: Brennan Chapman & Lloyd Alvarez//                                                                          // Creates a complete duplicate of a comp hierarchy including subcomps.     // Also, makes sure if a comp is used multiple times that it only gets duplicated   // once and all remaining references point to the first duplicate.               //// Version History// 1.0 initial release - 04/2010// 2.0 Added UI,  search and replace new comp name, maintian hierarchy and arrange into new folder option, non-english AE support, blessed for CS5 - 05/2010// 2.1 Fixed folder hierarchy when using add into new folder option and CS3 comp name limit bug  - 08/2010// 2.2 Fixed bug when running script from Scripts menu - 02/2011 (LA)//////////////////////////////////////////////////////////////////////////var tcd_scriptName = "True Comp Duplicator";var tcd_version = "2.2";var tcd_folderNameDef = "Duplicated Comps";function tcd_buildUI(thisObj) {        if (thisObj instanceof Panel) {        var myPal = thisObj;    } else {        var myPal = new Window("palette",tcd_scriptName + " v" + tcd_version,undefined, {resizeable:true});    }    if (myPal != null) {                var res =         "group { \                    alignment: ['fill','fill'], \                    alignChildren: ['left','top'], \                    orientation: 'column', \          match: Group { \                       alignment: ['fill','top'], \                    alignChildren: ['fill','top'], \                    orientation:'column', \                   suffix: Group { \                       alignment: ['fill','top'], \                    alignChildren: ['fill','top'], \                    suffixTxt: StaticText {text:'New comp name', alignment: ['left','center']}, \                      suffixOption: DropDownList {alignment: ['left','center']}, \                    suffixString: EditText {alignment: ['fill','center']}, \                    } \                    } \                       addFolder: Checkbox {text:'Arrange duplicated comps into new folder'}, \               folder: Group { \                       alignment: ['fill','top'], \                    alignChildren: ['fill','top'], \                    addFolderTxt: StaticText {text:'New folder name:', alignment: ['left','center']}, \                    addFolderName: EditText {alignment: ['fill','center']}, \                    } \                    doItBtn: Button {text: 'Duplicate', alignment: ['right','top']} , \                }";                myPal.grp = myPal.add(res);                if (app.settings.haveSetting("True Comp Duplicator", "addFolder"))           {myPal.grp.addFolder.value =! (app.settings.getSetting("True Comp Duplicator", "addFolder") == "false");}                     var suffixOptions = ["suffix","replace"];        for (var i=0; i<suffixOptions.length; i++) {            myPal.grp.match.suffix.suffixOption.add("item",suffixOptions[i]);        }        myPal.grp.match.suffix.suffixOption.selection = 0;        myPal.grp.match.suffix.suffixOption.minimumSize.width = myPal.grp.match.suffix.suffixOption.preferredSize.width = 75;                 if (app.settings.haveSetting("True Comp Duplicator", "suffixOption")) {           myPal.grp.match.suffix.suffixOption.selection = parseFloat(app.settings.getSetting("True Comp Duplicator", "suffixOption"));           if (myPal.grp.match.suffix.suffixOption.selection.text == "replace") tcd_addMatchUI (true);        }                 if (app.settings.haveSetting("True Comp Duplicator", "suffixName"))            myPal.grp.match.suffix.suffixString.text = app.settings.getSetting("True Comp Duplicator", "suffixName");                         myPal.grp.match.suffix.suffixString.onChange = myPal.grp.match.suffix.suffixString.onChanging = function () {            app.settings.saveSetting("True Comp Duplicator", "suffixName", this.text);        }                 function tcd_addMatchUI (replaceMatch) {            if (myPal.grp.match.suffix.suffixOption.selection.text == "replace") {                var tcd_addMatch = "group { \                               alignment: ['fill','top'], \                                alignChildren: ['fill','top'], \                                matchTxt: StaticText {text:'with', alignment: ['left','top']}, \                                matchString: EditText {alignment: ['fill','top']}, \                                } ";                myPal.grp.match.match =  myPal.grp.match.add(tcd_addMatch);                myPal.layout.layout(true);                myPal.layout.resize();           }  else {// if (myPal.grp.suffix.suffixOption.selection.text == "replace")                  myPal.grp.match.remove(myPal.grp.match.match);                myPal.layout.layout(true);                myPal.layout.resize();            }// else(myPal.grp.suffix.suffixOption.selection.text == "replace")                                 app.settings.saveSetting("True Comp Duplicator", "suffixOption",  myPal.grp.match.suffix.suffixOption.selection.index);                    if (replaceMatch) {                 if (app.settings.haveSetting("True Comp Duplicator", "replaceString"))                    myPal.grp.match.match.matchString.text = app.settings.getSetting("True Comp Duplicator", "replaceString");                                                 myPal.grp.match.match.matchString.onChange = myPal.grp.match.match.matchString.onChanging = function () {                        app.settings.saveSetting("True Comp Duplicator", "replaceString", this.text);                }            }//if (replaceMatch)                }//function tcd_addMatchUI ()                  myPal.grp.match.suffix.suffixOption.onChange = function () {            if (this.selection.text == "replace") tcd_addMatchUI (true); else tcd_addMatchUI (false);         }// myPal.grp.suffix.suffixOption.onChange = function ()                 myPal.grp.folder.visible =  myPal.grp.addFolder.value;        myPal.grp.addFolder.onClick = function () {            myPal.grp.folder.visible = this.value;            app.settings.saveSetting("True Comp Duplicator", "addFolder", this.value);        }               if (app.settings.haveSetting("True Comp Duplicator", "folderName"))            myPal.grp.folder.addFolderName.text = app.settings.getSetting("True Comp Duplicator", "folderName");        else myPal.grp.folder.addFolderName.text = tcd_folderNameDef;                myPal.grp.folder.addFolderName.onChanging = myPal.grp.folder.addFolderName.onChange= function () {            app.settings.saveSetting("True Comp Duplicator", "folderName", this.text);        }                        myPal.grp.doItBtn.onClick = function () {            tcd_addFolder = myPal.grp.addFolder.value;            tcd_folderName = myPal.grp.folder.addFolderName.text;               var checkError = false;            if (myPal.grp.match.suffix.suffixOption.selection.text == "suffix" && myPal.grp.match.suffix.suffixString.text != "") {                tcd_mode = 1; // Add Suffix                tcd_suffix = myPal.grp.match.suffix.suffixString.text;            } else if (myPal.grp.match.suffix.suffixOption.selection.text == "replace") {                if (myPal.grp.match.suffix.suffixString.text != "") {                        tcd_mode = 2; // Search and replace name                        tcd_replaceTerm = myPal.grp.match.match.matchString.text;                        tcd_searchTerm = myPal.grp.match.suffix.suffixString.text;                } else {                        alert("Missing value to search for when replacing the name.");                        checkError = true;                }            } else {                tcd_mode = 0;  //No changes to name            }               if (checkError == false) tcd_doIt ();        } //myPal.grp.doItBtn.onClick = function ()                         myPal.layout.layout(true);        myPal.layout.resize();        myPal.onResizing = myPal.onResize = function () {this.layout.resize();}                 } //if (myPal != null)    return myPal;    }function duplicateStructure(comp, tcd_parentFolder) {        // Duplicate the incoming comp    var newCompName = tcd_changeName(comp.name);    var comp = comp.duplicate();    if (tcd_mode > 0) { comp.name = newCompName; }        //if (tcd_addFolder) comp.parentFolder = tcd_parentFolder;        // For each of the layers in the comp, check for subcomps    for (var i=1; i<=comp.numLayers; i++) {        var layer = comp.layer(i);        //Check if layer has a source and that its type is a composition        if (layer.source && layer.source instanceof CompItem) {                    // Check if this comp has already been duplicated            check = checkPreviousComps(layer.source.id);                        if (check == null) {                // The subcomp hasn't been duplicated before                                // Store the original comp id to remember the correlation                var sourceID = layer.source.id;                // Replace the source of the layer, and recursively check in that subcomp for sub-subcomps                layer.replaceSource(duplicateStructure(layer.source, tcd_parentFolder), false);                 // Store the new comp id to remember the correlation                var destID = layer.source.id;                //Add the correlation to an array                previousComps[sourceID] = destID;            } else {                // Replace the source with the already duplicated comp                layer.replaceSource(check, false);            }        }    }    //Check if folder structure should be duplicated    if (tcd_addFolder) {        //Set the root folder        previousFolders[0] = tcd_parentFolder.id;        //Duplicate the folder structure        comp.parentFolder = duplicateFolderStructure(comp.parentFolder);     }     // For the recursion, return the duplicate comp    return comp;}function duplicateFolderStructure(folder) {    //Check if the parent folder is root    check = checkPreviousFolders(folder.id, );    // If the folder hasn't been duplicated yet...    if (folder == tcd_origParentFolder) {        return tcd_parentFolder;    } else if (check == null) {        var sourceID = folder.id;        var newFolder = app.project.items.addFolder(tcd_changeName(folder.name));        var destID = newFolder.id;        previousFolders[sourceID] = destID;        var aFolder = folder;        if (folder.parentFolder != null) {            newFolder.parentFolder = duplicateFolderStructure(folder.parentFolder);        }        return newFolder;     } else {        return check;    }}// Checks previous duplications to make sure a comp isn't duplicated twicefunction checkPreviousComps(checkID) {    if (previousComps[checkID]) {        return getItemWithID(previousComps[checkID]);    }    return null;}function checkPreviousFolders(checkID) {    if (previousFolders[checkID]) {        return getItemWithID(previousFolders[checkID]);    }    return null}    // Returns the proect item with the specified IDfunction getItemWithID(id) {    for (x=1; x<=app.project.numItems; x++) {        if (app.project.item(x).id == id) {            return app.project.item(x);        }    }    return null;}function tcd_changeName(name) {    if (tcd_mode == 1) {        name = name + tcd_suffix;        if (parseFloat(app.version) < 9) name = name.substring(0,29);  //CS3 has a 31 character limit    } else if (tcd_mode == 2) {        var tcd_searchTermCleaned = tcd_searchTerm.replace(/[-[\]{}()*+?.\\^$|,#\s]/g, "\\$&");  //escape REGEX Special Characters        var tcd_searchTermRegex = new RegExp (tcd_searchTermCleaned, "g");        name = name.replace(tcd_searchTermRegex, tcd_replaceTerm);        if (parseFloat(app.version) < 9) name = name.substring(0,29);  //CS3 has a 31 character limit    }    return name;}function tcd_doIt (){    mainComp = app.project.activeItem;        if (mainComp && mainComp instanceof CompItem) {        app.beginUndoGroup("True Comp Duplicator");        // Reset the list for each time the function is run        previousComps = [];        previousFolders = [];                // Go!        if (tcd_addFolder) {                tcd_parentFolder = app.project.items.addFolder(tcd_folderName);                // If the mainComp is not in the root of the project, then put the new folder on the same heirarchy level as the original parent folder                if (mainComp.parentFolder.parentFolder) {                    tcd_parentFolder.parentFolder = mainComp.parentFolder.parentFolder;                } else {                    tcd_parentFolder.parentFolder = mainComp.parentFolder;                }                previousFolders[mainComp.parentFolder.id] = tcd_parentFolder.id;                tcd_origParentFolder = mainComp.parentFolder;             }                        duplicateStructure(mainComp, tcd_parentFolder);            app.endUndoGroup();    } else if (!mainComp) {        alert("Please select a single comp in the project panel to duplicate.");    } else {        alert("ERROR: No comp selected.\n   Please select a comp in the project panel.");    }} //function tcd_doIt (palObj)var tcd_mode = 0; // 0 - none, 1 - add suffix, 2 - search and replacevar tcd_suffix = "";var tcd_searchTerm = "";var tcd_replaceTerm = "";//mainvar myPalette = tcd_buildUI(this);var tcd_folderName, tcd_addFolder, tcd_origParentFolder, tcd_parentFolder, previousComps, previousFolders;if (parseFloat(app.version) < 8) {    alert("This script requires Adobe After Effects CS3 or later.", tcd_scriptName);    } else {    if (myPalette != null && myPalette instanceof Window) {        //myPalette.center();                myPalette.show();    }}}